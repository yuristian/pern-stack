import type { ArcjetRule, ArcjetMode, ArcjetLogger, ArcjetWellKnownBot, ArcjetBotCategory, ArcjetEmailType, ArcjetSensitiveInfoType } from "@arcjet/protocol";
import { ArcjetDecision } from "@arcjet/protocol";
import type { Client } from "@arcjet/protocol/client.js";
export * from "@arcjet/protocol";
type Simplify<T> = {
    [KeyType in keyof T]: T[KeyType];
} & {};
type UnionToIntersection<Union> = (Union extends unknown ? (distributedUnion: Union) => void : never) extends (mergedIntersection: infer Intersection) => void ? // The `& Union` is to allow indexing by the resulting type
Intersection & Union : never;
type IsNever<T> = [T] extends [never] ? true : false;
type LiteralCheck<T, LiteralType extends null | undefined | string | number | boolean | symbol | bigint> = IsNever<T> extends false ? [T] extends [LiteralType] ? [LiteralType] extends [T] ? false : true : false : false;
type IsStringLiteral<T> = LiteralCheck<T, string>;
export type TokenBucketRateLimitOptions<Characteristics extends readonly string[]> = {
    mode?: ArcjetMode;
    characteristics?: Characteristics;
    refillRate: number;
    interval: string | number;
    capacity: number;
};
export type FixedWindowRateLimitOptions<Characteristics extends readonly string[]> = {
    mode?: ArcjetMode;
    characteristics?: Characteristics;
    window: string | number;
    max: number;
};
export type SlidingWindowRateLimitOptions<Characteristics extends readonly string[]> = {
    mode?: ArcjetMode;
    characteristics?: Characteristics;
    interval: string | number;
    max: number;
};
export type BotOptionsAllow = {
    mode?: ArcjetMode;
    allow: Array<ArcjetWellKnownBot | ArcjetBotCategory>;
    deny?: never;
};
export type BotOptionsDeny = {
    mode?: ArcjetMode;
    allow?: never;
    deny: Array<ArcjetWellKnownBot | ArcjetBotCategory>;
};
export type BotOptions = BotOptionsAllow | BotOptionsDeny;
export type EmailOptionsAllow = {
    mode?: ArcjetMode;
    allow: ArcjetEmailType[];
    block?: never;
    deny?: never;
    requireTopLevelDomain?: boolean;
    allowDomainLiteral?: boolean;
};
export type EmailOptionsDeny = {
    mode?: ArcjetMode;
    allow?: never;
    block?: never;
    deny: ArcjetEmailType[];
    requireTopLevelDomain?: boolean;
    allowDomainLiteral?: boolean;
};
type EmailOptionsBlock = {
    mode?: ArcjetMode;
    allow?: never;
    /** @deprecated use `deny` instead */
    block: ArcjetEmailType[];
    deny?: never;
    requireTopLevelDomain?: boolean;
    allowDomainLiteral?: boolean;
};
export type EmailOptions = EmailOptionsAllow | EmailOptionsDeny | EmailOptionsBlock;
type DetectSensitiveInfoEntities<T> = (tokens: string[]) => Array<ArcjetSensitiveInfoType | T | undefined>;
type ValidEntities<Detect> = Array<undefined extends Detect ? ArcjetSensitiveInfoType : Detect extends DetectSensitiveInfoEntities<infer CustomEntities> ? ArcjetSensitiveInfoType | CustomEntities : never>;
export type SensitiveInfoOptionsAllow<Detect> = {
    allow: ValidEntities<Detect>;
    deny?: never;
    contextWindowSize?: number;
    mode?: ArcjetMode;
    detect?: Detect;
};
export type SensitiveInfoOptionsDeny<Detect> = {
    allow?: never;
    deny: ValidEntities<Detect>;
    contextWindowSize?: number;
    mode?: ArcjetMode;
    detect?: Detect;
};
export type SensitiveInfoOptions<Detect> = SensitiveInfoOptionsAllow<Detect> | SensitiveInfoOptionsDeny<Detect>;
type PlainObject = {
    [key: string]: unknown;
};
export type Primitive<Props extends PlainObject = {}> = [ArcjetRule<Props>];
export type Product<Props extends PlainObject = {}> = ArcjetRule<Props>[];
type PropsForCharacteristic<T> = IsStringLiteral<T> extends true ? T extends "ip.src" | "http.host" | "http.method" | "http.request.uri.path" | `http.request.headers["${string}"]` | `http.request.cookie["${string}"]` | `http.request.uri.args["${string}"]` ? {} : T extends string ? Record<T, string | number | boolean> : never : {};
export type CharacteristicProps<Characteristics extends readonly string[]> = UnionToIntersection<PropsForCharacteristic<Characteristics[number]>>;
type PropsForRule<R> = R extends ArcjetRule<infer Props> ? Props : {};
export type ExtraProps<Rules> = Rules extends [] ? {} : Rules extends ArcjetRule[][] ? UnionToIntersection<PropsForRule<Rules[number][number]>> : Rules extends ArcjetRule[] ? UnionToIntersection<PropsForRule<Rules[number]>> : never;
/**
 * Additional context that can be provided by adapters.
 *
 * Among other things, this could include the Arcjet API Key if it were only
 * available in a runtime handler or IP details provided by a platform.
 */
export type ArcjetAdapterContext = {
    [key: string]: unknown;
    getBody(): Promise<string | undefined>;
    waitUntil?: (promise: Promise<unknown>) => void;
};
/**
 * @property {string} ip - The IP address of the client.
 * @property {string} method - The HTTP method of the request.
 * @property {string} protocol - The protocol of the request.
 * @property {string} host - The host of the request.
 * @property {string} path - The path of the request.
 * @property {Headers} headers - The headers of the request.
 * @property {string} cookies - The string representing semicolon-separated Cookies for a request.
 * @property {string} query - The `?`-prefixed string representing the Query for a request. Commonly referred to as a "querystring".
 * @property {string} email - An email address related to the request.
 * @property ...extra - Extra data that might be useful for Arcjet. For example, requested tokens are specified as the `requested` property.
 */
export type ArcjetRequest<Props extends PlainObject> = Simplify<{
    [key: string]: unknown;
    ip?: string;
    method?: string;
    protocol?: string;
    host?: string;
    path?: string;
    headers?: Headers | Record<string, string | string[] | undefined>;
    cookies?: string;
    query?: string;
} & Props>;
export declare function tokenBucket<const Characteristics extends readonly string[] = []>(options: TokenBucketRateLimitOptions<Characteristics>): Primitive<Simplify<UnionToIntersection<{
    requested: number;
} | CharacteristicProps<Characteristics>>>>;
export declare function fixedWindow<const Characteristics extends readonly string[] = []>(options: FixedWindowRateLimitOptions<Characteristics>): Primitive<Simplify<CharacteristicProps<Characteristics>>>;
export declare function slidingWindow<const Characteristics extends readonly string[] = []>(options: SlidingWindowRateLimitOptions<Characteristics>): Primitive<Simplify<CharacteristicProps<Characteristics>>>;
export declare function sensitiveInfo<const Detect extends DetectSensitiveInfoEntities<CustomEntities> | undefined, const CustomEntities extends string>(options: SensitiveInfoOptions<Detect>): Primitive<{}>;
export declare function validateEmail(options: EmailOptions): Primitive<{
    email: string;
}>;
export declare function detectBot(options: BotOptions): Primitive<{}>;
export type ShieldOptions = {
    mode?: ArcjetMode;
};
export declare function shield(options: ShieldOptions): Primitive<{}>;
export type ProtectSignupOptions<Characteristics extends readonly string[]> = {
    rateLimit: SlidingWindowRateLimitOptions<Characteristics>;
    bots: BotOptions;
    email: EmailOptions;
};
export declare function protectSignup<const Characteristics extends string[] = []>(options: ProtectSignupOptions<Characteristics>): Product<Simplify<UnionToIntersection<{
    email: string;
} | CharacteristicProps<Characteristics>>>>;
export interface ArcjetOptions<Rules extends [...(Primitive | Product)[]], Characteristics extends readonly string[]> {
    /**
     * The API key to identify the site in Arcjet.
     */
    key: string;
    /**
     * Rules to apply when protecting a request.
     */
    rules: readonly [...Rules];
    /**
     * Characteristics to be used to uniquely identify clients.
     */
    characteristics?: Characteristics;
    /**
     * The client used to make requests to the Arcjet API. This must be set
     * when creating the SDK, such as inside @arcjet/next or mocked in tests.
     */
    client?: Client;
    /**
     * The logger used to emit useful information from the SDK.
     */
    log?: ArcjetLogger;
}
/**
 * The Arcjet client provides a public `protect()` method to
 * make a decision about how a request should be handled.
 */
export interface Arcjet<Props extends PlainObject> {
    /**
     * Make a decision about how to handle a request. This will analyze the
     * request locally where possible and call the Arcjet decision API.
     *
     * @param {ArcjetAdapterContext} ctx - Additional context for this function call.
     * @param {ArcjetRequest} request - Details about the {@link ArcjetRequest} that Arcjet needs to make a decision.
     * @returns An {@link ArcjetDecision} indicating Arcjet's decision about the request.
     */
    protect(ctx: ArcjetAdapterContext, request: ArcjetRequest<Props>): Promise<ArcjetDecision>;
    /**
     * Augments the client with another rule. Useful for varying rules based on
     * criteria in your handlerâ€”e.g. different rate limit for logged in users.
     *
     * @param rule The rule to add to this execution.
     * @returns An augmented {@link Arcjet} client.
     */
    withRule<Rule extends Primitive | Product>(rule: Rule): Arcjet<Simplify<Props & ExtraProps<Rule>>>;
}
/**
 * Create a new Arcjet client with the specified {@link ArcjetOptions}.
 *
 * @param options {ArcjetOptions} Arcjet configuration options.
 */
export default function arcjet<const Rules extends [...(Primitive | Product)[]] = [], const Characteristics extends readonly string[] = []>(options: ArcjetOptions<Rules, Characteristics>): Arcjet<Simplify<ExtraProps<Rules> & CharacteristicProps<Characteristics>>>;
