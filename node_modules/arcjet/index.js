import { ArcjetRuleResult, ArcjetBotReason, ArcjetEmailReason, ArcjetErrorReason, ArcjetSensitiveInfoReason, ArcjetErrorDecision, ArcjetReason, ArcjetDenyDecision } from '@arcjet/protocol';
export * from '@arcjet/protocol';
import { isRateLimitRule } from '@arcjet/protocol/convert.js';
import * as analyze from '@arcjet/analyze';
import * as duration from '@arcjet/duration';
import ArcjetHeaders from '@arcjet/headers';
import { runtime } from '@arcjet/runtime';

function assert(condition, msg) {
    if (!condition) {
        throw new Error(msg);
    }
}
function nowInSeconds() {
    return Math.floor(Date.now() / 1000);
}
class Cache {
    expires;
    data;
    constructor() {
        this.expires = new Map();
        this.data = new Map();
    }
    get(key) {
        const ttl = this.ttl(key);
        if (ttl > 0) {
            return this.data.get(key);
        }
        else {
            // Cleanup if expired
            this.expires.delete(key);
            this.data.delete(key);
        }
    }
    set(key, value, expiresAt) {
        this.expires.set(key, expiresAt);
        this.data.set(key, value);
    }
    ttl(key) {
        const now = nowInSeconds();
        const expiresAt = this.expires.get(key) ?? now;
        return expiresAt - now;
    }
}
function errorMessage(err) {
    if (err) {
        if (typeof err === "string") {
            return err;
        }
        if (typeof err === "object" &&
            "message" in err &&
            typeof err.message === "string") {
            return err.message;
        }
    }
    return "Unknown problem";
}
const knownFields = [
    "ip",
    "method",
    "protocol",
    "host",
    "path",
    "headers",
    "body",
    "email",
    "cookies",
    "query",
];
function isUnknownRequestProperty(key) {
    return !knownFields.includes(key);
}
function isEmailType(type) {
    return (type === "FREE" ||
        type === "DISPOSABLE" ||
        type === "NO_MX_RECORDS" ||
        type === "NO_GRAVATAR" ||
        type === "INVALID");
}
class Performance {
    log;
    constructor(logger) {
        this.log = logger;
    }
    // TODO(#2020): We should no-op this if loglevel is not `debug` to do less work
    measure(label) {
        const start = performance.now();
        return () => {
            const end = performance.now();
            const diff = end - start;
            this.log.debug("LATENCY %s: %sms", label, diff.toFixed(3));
        };
    }
}
function toString(value) {
    if (typeof value === "string") {
        return value;
    }
    if (typeof value === "number") {
        return `${value}`;
    }
    if (typeof value === "boolean") {
        return value ? "true" : "false";
    }
    return "<unsupported value>";
}
// This is the Symbol that Vercel defines in their infrastructure to access the
// Context (where available). The Context can contain the `waitUntil` function.
// https://github.com/vercel/vercel/blob/930d7fb892dc26f240f2b950d963931c45e1e661/packages/functions/src/get-context.ts#L6
const SYMBOL_FOR_REQ_CONTEXT = Symbol.for("@vercel/request-context");
function lookupWaitUntil() {
    const fromSymbol = globalThis;
    if (typeof fromSymbol[SYMBOL_FOR_REQ_CONTEXT] === "object" &&
        fromSymbol[SYMBOL_FOR_REQ_CONTEXT] !== null &&
        "get" in fromSymbol[SYMBOL_FOR_REQ_CONTEXT] &&
        typeof fromSymbol[SYMBOL_FOR_REQ_CONTEXT].get === "function") {
        const vercelCtx = fromSymbol[SYMBOL_FOR_REQ_CONTEXT].get();
        if (typeof vercelCtx === "object" &&
            vercelCtx !== null &&
            "waitUntil" in vercelCtx &&
            typeof vercelCtx.waitUntil === "function") {
            return vercelCtx.waitUntil;
        }
    }
}
function toAnalyzeRequest(request) {
    const headers = {};
    if (typeof request.headers !== "undefined") {
        for (const [key, value] of request.headers.entries()) {
            headers[key] = value;
        }
    }
    return {
        ...request,
        headers,
    };
}
function extraProps(details) {
    const extra = new Map();
    for (const [key, value] of Object.entries(details)) {
        if (isUnknownRequestProperty(key)) {
            extra.set(key, toString(value));
        }
    }
    return Object.fromEntries(extra.entries());
}
function createTypeValidator(...types) {
    return (key, value) => {
        const typeOfValue = typeof value;
        if (!types.includes(typeOfValue)) {
            if (types.length === 1) {
                throw new Error(`invalid type for \`${key}\` - expected ${types[0]}`);
            }
            else {
                throw new Error(`invalid type for \`${key}\` - expected one of ${types.join(", ")}`);
            }
        }
        else {
            return false;
        }
    };
}
function createValueValidator(
// This uses types to ensure we have at least 2 values
...values) {
    return (key, value) => {
        // We cast the values to unknown because the optionValue isn't known but
        // we only want to use `values` on string enumerations
        if (!values.includes(value)) {
            throw new Error(`invalid value for \`${key}\` - expected one of ${values.map((value) => `'${value}'`).join(", ")}`);
        }
    };
}
function createArrayValidator(validate) {
    return (key, value) => {
        if (Array.isArray(value)) {
            for (const [idx, item] of value.entries()) {
                validate(`${key}[${idx}]`, item);
            }
        }
        else {
            throw new Error(`invalid type for \`${key}\` - expected an array`);
        }
    };
}
function createValidator({ rule, validations, }) {
    return (options) => {
        for (const { key, validate, required } of validations) {
            if (required && !Object.hasOwn(options, key)) {
                throw new Error(`\`${rule}\` options error: \`${key}\` is required`);
            }
            const value = options[key];
            // The `required` flag is checked above, so these should only be validated
            // if the value is not undefined.
            if (typeof value !== "undefined") {
                try {
                    validate(key, value);
                }
                catch (err) {
                    throw new Error(`\`${rule}\` options error: ${errorMessage(err)}`);
                }
            }
        }
    };
}
const validateString = createTypeValidator("string");
const validateNumber = createTypeValidator("number");
const validateBoolean = createTypeValidator("boolean");
const validateFunction = createTypeValidator("function");
const validateStringOrNumber = createTypeValidator("string", "number");
const validateStringArray = createArrayValidator(validateString);
const validateMode = createValueValidator("LIVE", "DRY_RUN");
const validateEmailTypes = createArrayValidator(createValueValidator("DISPOSABLE", "FREE", "NO_MX_RECORDS", "NO_GRAVATAR", "INVALID"));
const validateTokenBucketOptions = createValidator({
    rule: "tokenBucket",
    validations: [
        {
            key: "mode",
            required: false,
            validate: validateMode,
        },
        {
            key: "characteristics",
            validate: validateStringArray,
            required: false,
        },
        { key: "refillRate", required: true, validate: validateNumber },
        { key: "interval", required: true, validate: validateStringOrNumber },
        { key: "capacity", required: true, validate: validateNumber },
    ],
});
const validateFixedWindowOptions = createValidator({
    rule: "fixedWindow",
    validations: [
        { key: "mode", required: false, validate: validateMode },
        {
            key: "characteristics",
            validate: validateStringArray,
            required: false,
        },
        { key: "max", required: true, validate: validateNumber },
        { key: "window", required: true, validate: validateStringOrNumber },
    ],
});
const validateSlidingWindowOptions = createValidator({
    rule: "slidingWindow",
    validations: [
        { key: "mode", required: false, validate: validateMode },
        {
            key: "characteristics",
            validate: validateStringArray,
            required: false,
        },
        { key: "max", required: true, validate: validateNumber },
        { key: "interval", required: true, validate: validateStringOrNumber },
    ],
});
const validateSensitiveInfoOptions = createValidator({
    rule: "sensitiveInfo",
    validations: [
        { key: "mode", required: false, validate: validateMode },
        { key: "allow", required: false, validate: validateStringArray },
        { key: "deny", required: false, validate: validateStringArray },
        { key: "contextWindowSize", required: false, validate: validateNumber },
        { key: "detect", required: false, validate: validateFunction },
    ],
});
const validateEmailOptions = createValidator({
    rule: "validateEmail",
    validations: [
        { key: "mode", required: false, validate: validateMode },
        { key: "block", required: false, validate: validateEmailTypes },
        { key: "allow", required: false, validate: validateEmailTypes },
        { key: "deny", required: false, validate: validateEmailTypes },
        {
            key: "requireTopLevelDomain",
            required: false,
            validate: validateBoolean,
        },
        { key: "allowDomainLiteral", required: false, validate: validateBoolean },
    ],
});
const validateBotOptions = createValidator({
    rule: "detectBot",
    validations: [
        { key: "mode", required: false, validate: validateMode },
        { key: "allow", required: false, validate: validateStringArray },
        { key: "deny", required: false, validate: validateStringArray },
    ],
});
const validateShieldOptions = createValidator({
    rule: "shield",
    validations: [{ key: "mode", required: false, validate: validateMode }],
});
const Priority = {
    SensitiveInfo: 1,
    Shield: 2,
    RateLimit: 3,
    BotDetection: 4,
    EmailValidation: 5,
};
function isLocalRule(rule) {
    return ("validate" in rule &&
        typeof rule.validate === "function" &&
        "protect" in rule &&
        typeof rule.protect === "function");
}
function tokenBucket(options) {
    validateTokenBucketOptions(options);
    const mode = options.mode === "LIVE" ? "LIVE" : "DRY_RUN";
    const characteristics = options.characteristics;
    const refillRate = options.refillRate;
    const interval = duration.parse(options.interval);
    const capacity = options.capacity;
    return [
        {
            type: "RATE_LIMIT",
            priority: Priority.RateLimit,
            mode,
            characteristics,
            algorithm: "TOKEN_BUCKET",
            refillRate,
            interval,
            capacity,
        },
    ];
}
function fixedWindow(options) {
    validateFixedWindowOptions(options);
    const mode = options.mode === "LIVE" ? "LIVE" : "DRY_RUN";
    const characteristics = Array.isArray(options.characteristics)
        ? options.characteristics
        : undefined;
    const max = options.max;
    const window = duration.parse(options.window);
    return [
        {
            type: "RATE_LIMIT",
            priority: Priority.RateLimit,
            mode,
            characteristics,
            algorithm: "FIXED_WINDOW",
            max,
            window,
        },
    ];
}
function slidingWindow(options) {
    validateSlidingWindowOptions(options);
    const mode = options.mode === "LIVE" ? "LIVE" : "DRY_RUN";
    const characteristics = Array.isArray(options.characteristics)
        ? options.characteristics
        : undefined;
    const max = options.max;
    const interval = duration.parse(options.interval);
    return [
        {
            type: "RATE_LIMIT",
            priority: Priority.RateLimit,
            mode,
            characteristics,
            algorithm: "SLIDING_WINDOW",
            max,
            interval,
        },
    ];
}
function protocolSensitiveInfoEntitiesToAnalyze(entity) {
    if (typeof entity !== "string") {
        throw new Error("invalid entity type");
    }
    if (entity === "EMAIL") {
        return { tag: "email" };
    }
    if (entity === "PHONE_NUMBER") {
        return { tag: "phone-number" };
    }
    if (entity === "IP_ADDRESS") {
        return { tag: "ip-address" };
    }
    if (entity === "CREDIT_CARD_NUMBER") {
        return { tag: "credit-card-number" };
    }
    return {
        tag: "custom",
        val: entity,
    };
}
function analyzeSensitiveInfoEntitiesToString(entity) {
    if (entity.tag === "email") {
        return "EMAIL";
    }
    if (entity.tag === "ip-address") {
        return "IP_ADDRESS";
    }
    if (entity.tag === "credit-card-number") {
        return "CREDIT_CARD_NUMBER";
    }
    if (entity.tag === "phone-number") {
        return "PHONE_NUMBER";
    }
    return entity.val;
}
function convertAnalyzeDetectedSensitiveInfoEntity(detectedEntities) {
    return detectedEntities.map((detectedEntity) => {
        return {
            ...detectedEntity,
            identifiedType: analyzeSensitiveInfoEntitiesToString(detectedEntity.identifiedType),
        };
    });
}
function sensitiveInfo(options) {
    validateSensitiveInfoOptions(options);
    const mode = options.mode === "LIVE" ? "LIVE" : "DRY_RUN";
    if (typeof options.allow !== "undefined" &&
        typeof options.deny !== "undefined") {
        throw new Error("`sensitiveInfo` options error: `allow` and `deny` cannot be provided together");
    }
    if (typeof options.allow === "undefined" &&
        typeof options.deny === "undefined") {
        throw new Error("`sensitiveInfo` options error: either `allow` or `deny` must be specified");
    }
    return [
        {
            type: "SENSITIVE_INFO",
            priority: Priority.SensitiveInfo,
            mode,
            allow: options.allow || [],
            deny: options.deny || [],
            validate(context, details) { },
            async protect(context, details) {
                const body = await context.getBody();
                if (typeof body === "undefined") {
                    return new ArcjetRuleResult({
                        ttl: 0,
                        state: "NOT_RUN",
                        conclusion: "ERROR",
                        reason: new ArcjetErrorReason("Couldn't read the body of the request to perform sensitive info identification."),
                    });
                }
                let convertedDetect = undefined;
                if (typeof options.detect !== "undefined") {
                    const detect = options.detect;
                    convertedDetect = (tokens) => {
                        return detect(tokens)
                            .filter((e) => typeof e !== "undefined")
                            .map(protocolSensitiveInfoEntitiesToAnalyze);
                    };
                }
                let entitiesTag = "allow";
                let entitiesVal = [];
                if (Array.isArray(options.allow)) {
                    entitiesTag = "allow";
                    entitiesVal = options.allow
                        .filter((e) => typeof e !== "undefined")
                        .map(protocolSensitiveInfoEntitiesToAnalyze);
                }
                if (Array.isArray(options.deny)) {
                    entitiesTag = "deny";
                    entitiesVal = options.deny
                        .filter((e) => typeof e !== "undefined")
                        .map(protocolSensitiveInfoEntitiesToAnalyze);
                }
                const entities = {
                    tag: entitiesTag,
                    val: entitiesVal,
                };
                const result = await analyze.detectSensitiveInfo(context, body, entities, options.contextWindowSize || 1, convertedDetect);
                const reason = new ArcjetSensitiveInfoReason({
                    denied: convertAnalyzeDetectedSensitiveInfoEntity(result.denied),
                    allowed: convertAnalyzeDetectedSensitiveInfoEntity(result.allowed),
                });
                if (result.denied.length === 0) {
                    return new ArcjetRuleResult({
                        ttl: 0,
                        state: "RUN",
                        conclusion: "ALLOW",
                        reason,
                    });
                }
                else {
                    return new ArcjetRuleResult({
                        ttl: 0,
                        state: "RUN",
                        conclusion: "DENY",
                        reason,
                    });
                }
            },
        },
    ];
}
function validateEmail(options) {
    validateEmailOptions(options);
    const mode = options.mode === "LIVE" ? "LIVE" : "DRY_RUN";
    if (typeof options.allow !== "undefined" &&
        typeof options.deny !== "undefined") {
        throw new Error("`validateEmail` options error: `allow` and `deny` cannot be provided together");
    }
    if (typeof options.allow !== "undefined" &&
        typeof options.block !== "undefined") {
        throw new Error("`validateEmail` options error: `allow` and `block` cannot be provided together");
    }
    if (typeof options.deny !== "undefined" &&
        typeof options.block !== "undefined") {
        throw new Error("`validateEmail` options error: `deny` and `block` cannot be provided together, `block` is now deprecated so `deny` should be preferred.");
    }
    if (typeof options.allow === "undefined" &&
        typeof options.deny === "undefined" &&
        typeof options.block === "undefined") {
        throw new Error("`validateEmail` options error: either `allow` or `deny` must be specified");
    }
    const allow = options.allow ?? [];
    const deny = options.deny ?? options.block ?? [];
    const requireTopLevelDomain = options.requireTopLevelDomain ?? true;
    const allowDomainLiteral = options.allowDomainLiteral ?? false;
    let config = {
        tag: "deny-email-validation-config",
        val: {
            requireTopLevelDomain,
            allowDomainLiteral,
            deny: [],
        },
    };
    if (typeof options.allow !== "undefined") {
        config = {
            tag: "allow-email-validation-config",
            val: {
                requireTopLevelDomain,
                allowDomainLiteral,
                allow: options.allow,
            },
        };
    }
    if (typeof options.deny !== "undefined") {
        config = {
            tag: "deny-email-validation-config",
            val: {
                requireTopLevelDomain,
                allowDomainLiteral,
                deny: options.deny,
            },
        };
    }
    if (typeof options.block !== "undefined") {
        config = {
            tag: "deny-email-validation-config",
            val: {
                requireTopLevelDomain,
                allowDomainLiteral,
                deny: options.block,
            },
        };
    }
    return [
        {
            type: "EMAIL",
            priority: Priority.EmailValidation,
            mode,
            allow,
            deny,
            requireTopLevelDomain,
            allowDomainLiteral,
            validate(context, details) {
                assert(typeof details.email !== "undefined", "ValidateEmail requires `email` to be set.");
            },
            async protect(context, { email }) {
                const result = await analyze.isValidEmail(context, email, config);
                if (result.validity === "valid") {
                    return new ArcjetRuleResult({
                        ttl: 0,
                        state: "RUN",
                        conclusion: "ALLOW",
                        reason: new ArcjetEmailReason({ emailTypes: [] }),
                    });
                }
                else {
                    const typedEmailTypes = result.blocked.filter(isEmailType);
                    return new ArcjetRuleResult({
                        ttl: 0,
                        state: "RUN",
                        conclusion: "DENY",
                        reason: new ArcjetEmailReason({
                            emailTypes: typedEmailTypes,
                        }),
                    });
                }
            },
        },
    ];
}
function detectBot(options) {
    validateBotOptions(options);
    const mode = options.mode === "LIVE" ? "LIVE" : "DRY_RUN";
    if (typeof options.allow !== "undefined" &&
        typeof options.deny !== "undefined") {
        throw new Error("`detectBot` options error: `allow` and `deny` cannot be provided together");
    }
    if (typeof options.allow === "undefined" &&
        typeof options.deny === "undefined") {
        throw new Error("`detectBot` options error: either `allow` or `deny` must be specified");
    }
    let config = {
        tag: "allowed-bot-config",
        val: {
            entities: [],
            skipCustomDetect: true,
        },
    };
    if (typeof options.allow !== "undefined") {
        config = {
            tag: "allowed-bot-config",
            val: {
                entities: options.allow,
                skipCustomDetect: true,
            },
        };
    }
    if (typeof options.deny !== "undefined") {
        config = {
            tag: "denied-bot-config",
            val: {
                entities: options.deny,
                skipCustomDetect: true,
            },
        };
    }
    return [
        {
            type: "BOT",
            priority: Priority.BotDetection,
            mode,
            allow: options.allow ?? [],
            deny: options.deny ?? [],
            validate(context, details) {
                if (typeof details.headers === "undefined") {
                    throw new Error("bot detection requires `headers` to be set");
                }
                if (typeof details.headers.has !== "function") {
                    throw new Error("bot detection requires `headers` to extend `Headers`");
                }
                if (!details.headers.has("user-agent")) {
                    throw new Error("bot detection requires user-agent header");
                }
            },
            /**
             * Attempts to call the bot detection on the headers.
             */
            async protect(context, request) {
                const result = await analyze.detectBot(context, toAnalyzeRequest(request), config);
                // If this is a bot and of a type that we want to block, then block!
                if (result.denied.length > 0) {
                    return new ArcjetRuleResult({
                        ttl: 60,
                        state: "RUN",
                        conclusion: "DENY",
                        reason: new ArcjetBotReason({
                            allowed: result.allowed,
                            denied: result.denied,
                            verified: result.verified,
                            spoofed: result.spoofed,
                        }),
                    });
                }
                else {
                    return new ArcjetRuleResult({
                        ttl: 0,
                        state: "RUN",
                        conclusion: "ALLOW",
                        reason: new ArcjetBotReason({
                            allowed: result.allowed,
                            denied: result.denied,
                            verified: result.verified,
                            spoofed: result.spoofed,
                        }),
                    });
                }
            },
        },
    ];
}
function shield(options) {
    validateShieldOptions(options);
    const mode = options.mode === "LIVE" ? "LIVE" : "DRY_RUN";
    return [
        {
            type: "SHIELD",
            priority: Priority.Shield,
            mode,
        },
    ];
}
function protectSignup(options) {
    return [
        ...slidingWindow(options.rateLimit),
        ...detectBot(options.bots),
        ...validateEmail(options.email),
    ];
}
/**
 * Create a new Arcjet client with the specified {@link ArcjetOptions}.
 *
 * @param options {ArcjetOptions} Arcjet configuration options.
 */
function arcjet(options) {
    // We destructure here to make the function signature neat when viewed by consumers
    const { key, rules } = options;
    const rt = runtime();
    // TODO: Separate the ArcjetOptions from the SDK Options
    // It is currently optional in the options so users can override it via an SDK
    if (typeof options.log === "undefined") {
        throw new Error("Log is required");
    }
    const log = options.log;
    const perf = new Performance(log);
    // TODO(#207): Remove this when we can default the transport so client is not required
    // It is currently optional in the options so the Next SDK can override it for the user
    if (typeof options.client === "undefined") {
        throw new Error("Client is required");
    }
    const client = options.client;
    // A local cache of block decisions. Might be emphemeral per request,
    // depending on the way the runtime works, but it's worth a try.
    // TODO(#132): Support configurable caching
    const blockCache = new Cache();
    const rootRules = rules
        .flat(1)
        .sort((a, b) => a.priority - b.priority);
    async function protect(rules, ctx, request) {
        // This goes against the type definition above, but users might call
        // `protect()` with no value and we don't want to crash
        if (typeof request === "undefined") {
            request = {};
        }
        const details = Object.freeze({
            ip: request.ip,
            method: request.method,
            protocol: request.protocol,
            host: request.host,
            path: request.path,
            headers: new ArcjetHeaders(request.headers),
            cookies: request.cookies,
            query: request.query,
            // TODO(#208): Re-add body
            // body: request.body,
            extra: extraProps(request),
            email: typeof request.email === "string" ? request.email : undefined,
        });
        const characteristics = options.characteristics
            ? [...options.characteristics]
            : [];
        const waitUntil = lookupWaitUntil();
        const baseContext = {
            key,
            log,
            characteristics,
            waitUntil,
            ...ctx,
        };
        let fingerprint = "";
        const logFingerprintPerf = perf.measure("fingerprint");
        try {
            fingerprint = await analyze.generateFingerprint(baseContext, toAnalyzeRequest(details));
            log.debug("fingerprint (%s): %s", rt, fingerprint);
        }
        catch (error) {
            log.error({ error }, "Failed to build fingerprint. Please verify your Characteristics.");
            const decision = new ArcjetErrorDecision({
                ttl: 0,
                reason: new ArcjetErrorReason(`Failed to build fingerprint - ${errorMessage(error)}`),
                // No results because we couldn't create a fingerprint
                results: [],
            });
            // TODO: Consider sending this to Report when we have an infallible fingerprint
            return decision;
        }
        finally {
            logFingerprintPerf();
        }
        const context = Object.freeze({
            ...baseContext,
            fingerprint,
            runtime: rt,
        });
        if (rules.length < 1) {
            // TODO(#607): Error if no rules configured after deprecation period
            log.warn("Calling `protect()` with no rules is deprecated. Did you mean to configure the Shield rule?");
        }
        if (rules.length > 10) {
            log.error("Failure running rules. Only 10 rules may be specified.");
            const decision = new ArcjetErrorDecision({
                ttl: 0,
                reason: new ArcjetErrorReason("Only 10 rules may be specified"),
                // No results because the sorted rules were too long and we don't want
                // to instantiate a ton of NOT_RUN results
                results: [],
            });
            client.report(context, details, decision, 
            // No rules because we've determined they were too long and we don't
            // want to try to send them to the server
            []);
            return decision;
        }
        const results = [];
        for (let idx = 0; idx < rules.length; idx++) {
            // Default all rules to NOT_RUN/ALLOW before doing anything
            results[idx] = new ArcjetRuleResult({
                ttl: 0,
                state: "NOT_RUN",
                conclusion: "ALLOW",
                reason: new ArcjetReason(),
            });
            // Add top-level characteristics to all Rate Limit rules that don't already have
            // their own set of characteristics.
            const candidate_rule = rules[idx];
            if (isRateLimitRule(candidate_rule)) {
                if (typeof candidate_rule.characteristics === "undefined") {
                    candidate_rule.characteristics = characteristics;
                    rules[idx] = candidate_rule;
                }
            }
        }
        const logLocalPerf = perf.measure("local");
        try {
            // We have our own local cache which we check first. This doesn't work in
            // serverless environments where every request is isolated, but there may be
            // some instances where the instance is not recycled immediately. If so, we
            // can take advantage of that.
            const logCachePerf = perf.measure("cache");
            const existingBlockReason = blockCache.get(fingerprint);
            logCachePerf();
            // If already blocked then we can async log to the API and return the
            // decision immediately.
            if (existingBlockReason) {
                const decision = new ArcjetDenyDecision({
                    ttl: blockCache.ttl(fingerprint),
                    reason: existingBlockReason,
                    // All results will be NOT_RUN because we used a cached decision
                    results,
                });
                client.report(context, details, decision, rules);
                log.debug({
                    id: decision.id,
                    conclusion: decision.conclusion,
                    fingerprint,
                    reason: existingBlockReason,
                    runtime: rt,
                }, "decide: already blocked");
                return decision;
            }
            for (const [idx, rule] of rules.entries()) {
                // This re-assignment is a workaround to a TypeScript error with
                // assertions where the name was introduced via a destructure
                let localRule;
                if (isLocalRule(rule)) {
                    localRule = rule;
                }
                else {
                    continue;
                }
                const logRulePerf = perf.measure(rule.type);
                try {
                    localRule.validate(context, details);
                    results[idx] = await localRule.protect(context, details);
                    // If a rule didn't return a rule result, we need to stub it to avoid
                    // crashing. This should only happen if a user writes a custom local
                    // rule incorrectly.
                    if (typeof results[idx] === "undefined") {
                        results[idx] = new ArcjetRuleResult({
                            ttl: 0,
                            state: "RUN",
                            conclusion: "ERROR",
                            reason: new ArcjetErrorReason("rule result missing"),
                        });
                    }
                    log.debug({
                        id: results[idx].ruleId,
                        rule: rule.type,
                        fingerprint,
                        path: details.path,
                        runtime: rt,
                        ttl: results[idx].ttl,
                        conclusion: results[idx].conclusion,
                        reason: results[idx].reason,
                    }, "Local rule result:");
                }
                catch (err) {
                    log.error("Failure running rule: %s due to %s", rule.type, errorMessage(err));
                    results[idx] = new ArcjetRuleResult({
                        ttl: 0,
                        state: "RUN",
                        conclusion: "ERROR",
                        reason: new ArcjetErrorReason(err),
                    });
                }
                finally {
                    logRulePerf();
                }
                if (results[idx].isDenied()) {
                    const decision = new ArcjetDenyDecision({
                        ttl: results[idx].ttl,
                        reason: results[idx].reason,
                        results,
                    });
                    // Only a DENY decision is reported to avoid creating 2 entries for a
                    // request. Upon ALLOW, the `decide` call will create an entry for the
                    // request.
                    client.report(context, details, decision, rules);
                    // If we're not in DRY_RUN mode, we want to cache non-zero TTL results
                    // and return this DENY decision.
                    if (rule.mode !== "DRY_RUN") {
                        if (results[idx].ttl > 0) {
                            log.debug({
                                fingerprint,
                                conclusion: decision.conclusion,
                                reason: decision.reason,
                            }, "Caching decision for %d seconds", decision.ttl);
                            blockCache.set(fingerprint, decision.reason, nowInSeconds() + decision.ttl);
                        }
                        return decision;
                    }
                    log.warn(`Dry run mode is enabled for "%s" rule. Overriding decision. Decision was: %s`, rule.type, decision.conclusion);
                }
            }
        }
        finally {
            logLocalPerf();
        }
        // With no cached values, we take a decision remotely. We use a timeout to
        // fail open.
        const logRemotePerf = perf.measure("remote");
        try {
            const logDediceApiPerf = perf.measure("decideApi");
            const decision = await client
                .decide(context, details, rules)
                .finally(() => {
                logDediceApiPerf();
            });
            // If the decision is to block and we have a non-zero TTL, we cache the
            // block locally
            if (decision.isDenied() && decision.ttl > 0) {
                log.debug("decide: Caching block locally for %d seconds", decision.ttl);
                blockCache.set(fingerprint, decision.reason, nowInSeconds() + decision.ttl);
            }
            return decision;
        }
        catch (err) {
            log.error("Encountered problem getting remote decision: %s", errorMessage(err));
            const decision = new ArcjetErrorDecision({
                ttl: 0,
                reason: new ArcjetErrorReason(err),
                results,
            });
            client.report(context, details, decision, rules);
            return decision;
        }
        finally {
            logRemotePerf();
        }
    }
    // This is a separate function so it can be called recursively
    function withRule(baseRules, rule) {
        const rules = [...baseRules, ...rule].sort((a, b) => a.priority - b.priority);
        return Object.freeze({
            withRule(rule) {
                return withRule(rules, rule);
            },
            async protect(ctx, request) {
                return protect(rules, ctx, request);
            },
        });
    }
    return Object.freeze({
        withRule(rule) {
            return withRule(rootRules, rule);
        },
        async protect(ctx, request) {
            return protect(rootRules, ctx, request);
        },
    });
}

export { arcjet as default, detectBot, fixedWindow, protectSignup, sensitiveInfo, shield, slidingWindow, tokenBucket, validateEmail };
